import io
import os
import streamlit as st
import pandas as pd
import openai
from openai import AssistantEventHandler
from openai.types.beta.threads import Text, TextDelta

# Inject CSS to make input bar sticky at the bottom
def inject_sticky_input_css():
    st.markdown("""
        <style>
        /* Sticky input bar at the bottom */
        div[data-testid="stTextInput"] > div {
            position: fixed;
            bottom: 0;
            width: 100%;
            padding: 10px;
            background-color: #0E1117;
            z-index: 9999;
        }
        .block-container {
            padding-bottom: 150px;  /* Space for the fixed input */
        }
        </style>
        """, unsafe_allow_html=True)

# Function to display the chat history
def display_chat_history():
    for message in st.session_state.chat_history:
        if message['role'] == 'user':
            st.chat_message("user").write(message['content'])
        else:
            st.chat_message("assistant").write(message['content'])

def ai_assistant_tab(df_filtered):
    inject_sticky_input_css()  # Inject CSS for sticky input bar

    st.header("AI Assistant")
    st.write("Ask questions about your data, and the assistant will analyze it using Python code.")

    # Initialize OpenAI client using API keys from Streamlit secrets
    client = openai.Client(api_key=st.secrets["OPENAI_API_KEY"])

    # Use existing assistant ID from Streamlit secrets
    assistant_id = st.secrets["OPENAI_ASSISTANT_ID"]  
    assistant = client.beta.assistants.retrieve(assistant_id)

    # Convert dataframe to a CSV file using io.BytesIO
    csv_buffer = io.BytesIO()
    df_filtered.to_csv(csv_buffer, index=False)
    csv_buffer.seek(0)  # Reset buffer position to the start

    # Upload the CSV file as binary data
    file = client.files.create(
        file=csv_buffer,
        purpose='assistants'
    )

    # Update the assistant to include the file
    client.beta.assistants.update(
        assistant_id,
        tool_resources={
            "code_interpreter": {
                "file_ids": [file.id]
            }
        }
    )

    # Initialize session state variables if not already present
    if 'chat_history' not in st.session_state:
        st.session_state.chat_history = []
    if 'thread_id' not in st.session_state:
        thread = client.beta.threads.create()
        st.session_state.thread_id = thread.id

    # Display chat history above the input
    display_chat_history()

    # Create a container for the input bar that is fixed at the bottom
    with st.container():
        # Input bar without using the class_ argument
        prompt = st.text_input("Enter your question about the data", key="input_prompt", label_visibility="collapsed")

        if prompt:
            # Display the user's message immediately
            with st.chat_message("user"):
                st.write(prompt)
            st.session_state.chat_history.append({'role': 'user', 'content': prompt})

            # Create a placeholder for the assistant's message
            with st.chat_message("assistant"):
                assistant_message_placeholder = st.empty()

            # Define event handler to capture assistant's response
            class MyEventHandler(AssistantEventHandler):
                def __init__(self, *args, **kwargs):
                    super().__init__(*args, **kwargs)
                    self.assistant_message = ""
                    self.placeholder = assistant_message_placeholder

                def on_text_delta(self, delta: TextDelta, snapshot: Text, **kwargs):
                    if delta and delta.value:
                        self.assistant_message += delta.value
                        self.placeholder.markdown(self.assistant_message)

            # Instantiate the event handler
            event_handler = MyEventHandler()

            # Create a new message in the thread
            client.beta.threads.messages.create(
                thread_id=st.session_state.thread_id,
                role="user",
                content=prompt
            )

            # Run the assistant and stream the response
            with client.beta.threads.runs.stream(
                thread_id=st.session_state.thread_id,
                assistant_id=assistant_id,
                event_handler=event_handler,
                temperature=0
            ) as stream:
                stream.until_done()

            # Add assistant's message to the chat history
            st.session_state.chat_history.append({'role': 'assistant', 'content': event_handler.assistant_message})

            # Handle any files generated by the assistant
            messages = client.beta.threads.messages.list(thread_id=st.session_state.thread_id)
            for message in messages.data:
                if message.role == 'assistant' and hasattr(message, 'attachments') and message.attachments:
                    for attachment in message.attachments:
                        if attachment.object == 'file':
                            file_id = attachment.file_id
                            # Download the file
                            file_content = client.files.content(file_id).read()
                            # Display the file content if appropriate
                            if attachment.filename.endswith(('.png', '.jpg', '.jpeg')):
                                st.image(file_content)
                            elif attachment.filename.endswith('.csv'):
                                # Read CSV into a dataframe
                                df = pd.read_csv(io.BytesIO(file_content))
                                st.write(df)
                            else:
                                st.download_button(
                                    label=f"Download {attachment.filename}",
                                    data=file_content,
                                    file_name=attachment.filename
                                )
